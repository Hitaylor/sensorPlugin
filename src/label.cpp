#include "label.h"

Label::Label()
{
    labelContent = NULL;
    printf("In the no param constructor, labelContent ptr = 0x%0x\n", labelContent);
}

/**
 * @brief Construct a new Labe::Labe object and alloc memory for the labelContent. if memory alloc failed, it throws a std::bad_alloc() exception.
 * 
 * @param aLabelName label name got from the plugin description xml file
 * @param aLabelPluginPath  label plugin path got from the plugin description xml file
 * @param aLabelContentLength label content length defined in the plugin description xml file
 */
Label::Label(std::string aLabelName, std::string aLabelPluginPath, int aLabelContentLength)
{
    printf("at begining of the constructor, labelContent ptr = 0x%0x\n", labelContent);
    labelName = aLabelName;
    labelPluginPath = aLabelPluginPath;
    labelContentLength = aLabelContentLength;
    if (labelContentLength < 1)
    {
#if (_DEBUG)
        {
            cerr << "labelContentLength should be positive number!\n";
        }
#endif
        labelName = "";
        labelPluginPath = "";
        labelContentLength = 0;
        labelContent = NULL;
#if (_DEBUG)
        {
            printf("negative labelContentLength， and the labelContent ptr =  0x%0x\n", labelContent);
        }
#endif
        throw std::bad_alloc();
    }
    else if (labelContentLength > LABEL_CONTENT_MAX_LENGTH)
    {
#if (_DEBUG)
        {
            cerr << "labelContentLength too large, its upper limits is " << LABEL_CONTENT_MAX_LENGTH << "!\n";
        }
#endif
        labelName = "";
        labelPluginPath = "";
        labelContentLength = 0;
        labelContent = NULL;
#if (_DEBUG)
        {
            printf("too large labelContentLength， and the labelContent ptr = 0x%0x\n", labelContent);
        }
#endif
        throw std::bad_alloc();
    }
    else
    {
        labelContent = malloc(labelContentLength);
        memset(labelContent, 0, labelContentLength);
#if (_DEBUG)
        {
            printf("Reasonable labelContentLength， and the labelContent ptr = 0x%0x\n", labelContent);
        }
#endif
    }
}

/**
 * @brief Destroy the Label::Label: object
 * 
 */
Label::~Label()
{
    labelName.clear();
    labelPluginPath.clear();
    labelContentLength = 0;
    if (labelContent)
    {
        free(labelContent);
    }
#if (_DEBUG)
    {
        cout << "Label object destroied!" << endl;
    }
#endif
}

/**
 * @brief  return the labelName member of the correspoding LabelPlugin object
 * 
 * @return std::string the labelName 
 */
std::string Label::getLabelName() const
{
    return labelName;
}

/**
 * @brief Set the labelName member of the correspoding LabelPlugin object
 * 
 * @param aLabelName name (description) of label content generated from the label generator plugin
 */
void Label::setLabelName(std::string aLabelName)
{
    labelName = aLabelName;
}

/**
 * @brief Get the labelPluginPath member of the correspoding LabelPlugin object
 * 
 * @return std::string path to the label generator plugin file (.so format)
 */
std::string Label::getLabelPluginPath()
{
    return labelPluginPath;
}

/**
 * @brief Set the labelPluginPath member of the correspoding LabelPlugin object
 * 
 * @param labelPluginPath path to the label generator plugin file (.so format)
 */
void Label::setLabelPluginPath(std::string labelPluginPath)
{
    labelPluginPath = labelPluginPath;
}

/**
 * @brief Get the labelContentLength member of the correspoding LabelPlugin object
 * 
 * @return int the length of the label content generated by the label plugin
 */
int Label::getLabelContentLength() const
{
    return labelContentLength;
}

/**
 * @brief Set the labelContentLength member of the correspoding LabelPlugin object
 * 
 * @param labelContentLength length of the label content
 */
void Label::setLabelContentLength(int labelContentLength)
{
    labelContentLength = labelContentLength;
}

/**
 * @brief Get the labelContent member of the correspoding LabelPlugin object
 * 
 * @return void* the content generated by the label generator plugin 
 */
void *Label::getLabelContent() const
{
    if (labelContent)
    {
        return labelContent;
    }
    else
    {
        cout << "labelContent = NULL\n"
             << endl;
        return 0;
    }
}

/**
 * @brief Set the labelContent member of the correspoding Label:: object
 * 
 * @param aLabelContent the content of the label
 */
void Label::setLabelContent(void *aLabelContent)
{
    labelContent = aLabelContent;
}

/**
 * @brief when using the default constructor @Label::Label() (no params), the labelContent will be null, so this function should be called to alloc memory for it.
 * 
 * @return int the result of allocing memory. 0 : success; 1 : labelContent is not null before calling this function; -1: failed 
 */
int Label::allocMemForLabelContent()
{
    if (labelContent == NULL)
    {
        try
        {
            labelContent = malloc(labelContentLength);
        }
        catch (bad_alloc &ex)
        {
#if (_DEBUG)
            {
                cerr << "[Label::allocMemoryForLabalContent()] Alloc memeory for label content failed!" << endl;
            }
#endif
            return -1;
        }

        return 0;
    }
    return 1;
}